# Примеры использования библиотеки ActiveSessions.
Данный репозиторий содержит примеры использования библиотеки ActiveSession ???Ссылка

## Проект SampleApplication
Первый проект, SampleApplication, содержит пример конфигурирования приложения для использования библиотеки ActiveSession и примеры применения стандартных исполнителей. Состоит этот проект из нескольких примеров, каждый из которых демонстрирует использование соответствующего исполнителя. Эти примеры слабо связаны между собой логически. Ссылки на каждый из примеров находится на входной странице приложения. 

### Стартовый код и входная страница
Код конфигурирования и запуска приложения в файле Program.cs дает пример конфигурирования приложения для использования библиотеки ActiveSession и всех ее стандартных исполнителей.

Входная страница (корневая страница приложения - Index.cshtml) содержит идентификатор текущей активной сессии и набор ссылок на примеры использования стандартных исполнителей библиотеки ActiveSession. Рядом с идентификатором активной сессии находится кнопка New. Нажатие на эту кнопку завершает текущую активную сессию и создает новую - делается это через обращение к точке вызова /api/terminate (обработчик этой точки вызывает метод IActiveSession.Terminate) и перезагрузку входной страницы, чтобы для нее создалась новая активная сессия. Завершение активной сессии прекращает выполнение всех работающих в ней исполнителей.

### Общая информация о примерах
Каждый пример содержит одну или две страницы Razor и набор точек вызова API. Тoчки вызова реализованы как действия контроллера API MVC. Если страниц Razor в примере две, то первая из них содержит форму для получения параметров для примера. Ссылка со входной страницы для такого примера ведет на эту страницу с формой. Обработчик формы проверяет введенные данные и вызывает (через HTTP Redirect) вторую страницу - страницу результата, которая содержит непосредственно пример использования исполнителя. Если параметры для примера собирать не требуется, то такой пример содержит только страницу результата, и ссылка на входной странице ведет непосредственно на страницу результата.
 
Страница результата - это страница Razor, которая используется для отображения параметров и результатов примера. С каждой страницей результата связан исполнитель, работу которого эта страница демонстрирует. Страница Razor создает HTML-страницу, возвращаемую браузеру на клиенте.Это содержимое создается при визуализации страницы обработчиком HTTP-метода GET (OnGet или OnGetAsync) в соответствии с параметрами примера. Начальное содержимое отображает параметры примера и начальный результат, полученный от исполнителя. 

Переданная в браузер HTML-страница содержит набор сценариев на JavaScript, которые получают от исполнителя дополнительные результаты, отображают их, а также - управляют исполнителем. Получение данных и управление исполнителем производится через точки вызова (любители жаргона называют их "ручки") API веб-приложения, в котором исполнитель выполняется на сервере в фоновом режиме. Эти точки вызова API реализуются методами действий класса SampleController. Все они будут перечислены ниже, в описании конкретных примеров. Точки вызова API получают в составе передаваемых им параметров внешний идентификатор исполнителя. Далее обработчики этих точек вызова, пользуясь внешним идентификатором исполнителя, проверяют, что текущая активная сессия не переменилась, находят запрошенный исполнитель по его номеру, переданному в составе внешнего идентификатора, и выполняют над этим исполнителем запрошенные через них действия.

Для каждой страницы обработчик закрытия страницы результатов посылает через API запрос на прекращение выполнения связанного с ней исполнителя - в точку вызова  /api/Abort (метод SampleController.Abort). Реализация обработчика точки вызова API Abort имеет особенность. Так как обработчик этой точки вызова может быть вызван из разных страниц примеров, с которыми связаны исполнители с разными типами результата, то этот обработчик, в отличие от других обработчиков точек вызова, не может использовать для получения интерфейса исполнителя (IRunner&lt;TResult&gt;) обобщенный, специфицированный типом результата, метод IActiveSession.GetRunner&lt;TResult&gt; или основанные на нем методы расширения: при указании неверного типа результата этот метод вместо ссылки на исполнитель вернет null. Вместо этого обработчик Abort получает методом IActiveSession.GetNonTypedRunner не зависящий от типа результата интерфейс исполнителя (не-обобщенный интерфейс IRunner) и вызывает метод исполнителя Abort через него.

### Примеры использования адаптеров перечислений (EnumAdapterRunner и AsyncEnumAdapterRunner)
Эти примеры показывают использование исполнителей - адаптеров перечислений. В библиотеке ActiveSession есть два типа таких адаптеров - адаптер для синхронного (IEnumerable&lt;TItem&gt;) перечисления  EnumAdapterRunner и адаптер для асинхронного (IAsyncEnumerable&lt;TItem&gt;) перечисления AsyncEnumAdapterRunner. Оба адаптера функционируют сходным образом, поэтому примеры их использования содержат одни и те же страницы.

Перечисления, используемые в примерах, возвращают последовательность результатов, которые получаются вызовами функции, генерирующей фиктивные данные. Эти фиктивные данные состоят из порядкового номера вызова, случайной строки и случайного числа. Перечисление может содержать несколько стадий (минимум - одну). На каждой из стадий функция получения результата вызывается указанное число раз с указанной задержкой между вызовами, которая может быть нулевой. 

На странице с формой получения параметров для этого примера, SequenceAdapterParams.cshtml можно указать количество изначально отображаемых записей, интервал между запросами дополнительных записей через API, максимальное количество возвращаемых за один запрос записей. В таблице ниже можно настроить стадии перечисления: добавить/удалить стадии и указать для каждой стадии выполняемое на ней число запросов и интервал между ними. 

Исполнитель, с которым работает страница результатов, создается обработчиком формы, и внешний идентификатор этого исполнителя (типа ExtRunnerKey) передается странице результатов через параметр маршрутизации ASP.NET Core - то есть, через сегмент пути в URL. А именно, обработчик формы после успешной проверки данных формы создает исполнитель нужного типа и через возвращаемый результат запрашивает перенаправление на страницу результатов. В свойство ExtraData интерфейса созданного исполнителя записывается ссылка на класс, содержащий полученные из формы  параметры примера. В путь URL для страницы результатов средствами генерации ссылок компонента маршрутизации подставляется внешний идентификатор исполнителя, преобразованный в строку методом ExtRunnerKey.ToString(). Так делать безопасно, потому что эта строка гарантированно содержит только допустимые в URL символы. 

При вызове обработчика метода GET страницы Razor результатов - SequenceShowResults.cshtml (этот обработчик - асинхронный, он имеет имя OnGetAsync) строка, представляющая внешний ключ исполнителя, становится, в соответствии с шаблоном адреса, значением параметра маршрутизации key. Этот параметр привязывается к одноименному входному параметру обработчика, имеющему тип ExtRunnerKey. Привязка производится с помощью вспомогательного класса ExtRunnerKeyMvcModelBinder с использованием в этом классе метода ExtRunnerKey.TryParse. Обработчик GET на основе информации из параметра проверяет, что текущая активная сессия не изменилась, и находит исполнитель.  После этого обработчик извлекает переданные ему по ссылке в свойстве ExtraData интерфейса исполнителя параметры примера и делает эти параметры и внешний ключ исполнителя доступными для визуализации на странице Razor. После всего этого обработчик извлекает (через метод исполнителя GetRequiredAsync, который, возможно, будет выполнен асинхронно) заданное в параметрах примера количество записей, делает их доступными странице Razor для визуализации и возвращает фреймворку результат, предписывающий визуализовать эту страницу. Код Razor, вызываемый фреймворком, визуализующий эту страницу, помимо всего прочего, сохраняет полученный им внешний ключ исполнителя в определенную на уровне страницы переменную JavaScript. Значение этой переменной впоследствии используется сценариями JavaScript, выполняющимися в браузере, для запросов к API приложения. 

На HTML-странице результатов этого примера слева отображаются параметры, используемые в примере. Справа показаны текущее состояние исполнителя и таблица с полученными от исполнителя данными. Изначально эта таблица содержит не более чем указанное в параметрах число записей. Впоследствии в нее добавляются дополнительные данные, полученные запросами к API (точка вызова /api/GetAvailable, метод SampleController.GetAvailable). Реализующий эту точку вызова метод действия контроллера API запрашивает у найденного исполнителя через его метод GetAvailable уже полученные в фоновом режиме из перечислителя, но ещё не возвращенные потребителю   записи - либо все, либо только указанное в параметрах примера их количество. Эти записи, вместе с текущим состоянием исполнителя, также возвращаемым методом GetAvailable, возвращаются как результат обращения к этой точке вызова и отображаются сценарием на странице в браузере.

Выполнение исполнителя можно прекратить, нажав кнопку Abort, расположенную под таблицей. При этом будет направлен запрос к API в точку вызова  /api/Abort (метод SampleController.Abort) - она рассмотрена ранее.


### Пример использования исполнителя временных последовательностей (TimeSeriesRunner)
Рассматриваемый пример отображает с заданной на его странице параметров периодичностью количество исполнителей - адаптеров последовательностей, создаваемых кодом первого примера (несколько экземпляров этого примера могут быть запущены одновременно), вместе с моментом времени, для которого происходит отображение.Чтобы иметь в приложении эти данные, в свойствах активной сессии (доступных через свойство IActiveSession сохраняется ссылка на экземпляр класса RunnerRegistry, отслеживающий создание и удаление исполнителей. Этот экземпляр создается в отложенном режиме при первом обращении к нему. Обработчик данных формы из предыдущего примера вызывает метод регистрации этого экземпляра для каждого созданного им исполнителя. Метод регистрации добавляет ссылку на созданный исполнитель в свой внутренний список. А чтобы отменить регистрацию исполнителя по его завершении, этот метод добавляет обработчик обратного вызова в маркер отмены, отменяемый при завершении исполнителя и доступный через свойство интерфейса исполнителя  IRunner.CompletionToken. Обработчик обратного вызова удаляет завершенный исполнитель из внутреннего списка экземпляра RunnerRegistry. Счетчик зарегистрированных таким образом исполнителей-адаптеров и отображается на указанные моменты времени в рассматриваемом примере.

Страница формы получения параметров этого примера (TimeSeriesParams.cshtml) содержит только одно поле - интервал времени  в секундах между записями (отсчетами), создаваемыми исполнителем временных последовательностей. Создание отслеживающего исполнителя, передача его идентификатора (внешнего) странице отображения результата  (TimeSeriesResults.cshtml) и сохранение этого идентификатора для использования в вызовах API в этом примере организована полностью аналогично предыдущему примеру. 

Обработчик метода GET страницы отображения результата после нахождения исполнителя запрашивает у него (вызовом метода GetRequiredAsync) первую запись, содержащую время и количество активных исполнителей-адаптеров на момент запуска отслеживающего исполнителя и визуализует страницу. Последующие записи извлекаются и отображаются исполняющимся на странице в браузере сценарием, который обращается за записями к точкам вызова API /api/GetTimeSeriesAvailRecords (метод действия GetTimeSeriesAvailRecords контроллера API) и /api/GetTimeSeriesRecordAsync (метод действия GetTimeSeriesRecordAsync контроллера API). Для обращения к API используется следующая логика. Сначала сценарий обращается из браузера к первой из указанных точек вызова с задержкой, чуть меньшей, чем установленный для исполнителя интервал между отсчетами, с запросом вернуть все полученные в фоновом режиме, но ещё не возвращенные отсчеты - это делается вызовом метода GetAvailable исполнителя обработчиком точки вызова. Если таких отсчетов нет, то сценарий обращается ко второй точке вызова, которая запрашивает у исполнителя получение следующего отсчета с ожиданием его появления - это делается  вызовом метода GetRequiredAsync.

Для прекращения работы этого примера необходимо закрыть страницу отображения результата - в этом случае обработчик события закрытия страницы пошлет запрос на прекращение выполнения исполнителя через уже упомянутую точку вызова /api/Abort.

### Пример использования исполнителя процесса активной сессии (SessionProcessRunner)
Этот пример демонстрирует использование исполнителя фонового процесса сессии. У этого примера нет дополнительных параметров, а потому страница с формой сбора параметров в нем отсутствует, а ссылка со входной страницы ведет сразу на страницу Razor результата (ObservationResults.cshtml). Исполнитель фонового процесса (далее - наблюдающий исполнитель) создается непосредственно в обработчике метода GET этой страницы.

Результат, который возвращает наблюдающий исполнитель - а исполнитель этого типа возвращает не набор записей, а единственный результат, который может изменяться со временем - это то же самое число активных исполнителей-адаптеров, что отслеживается и в предыдущем примере. Но отслеживание этого числа организовано по-другому. 

В активной сессии для этого примера создается и сохраняется (точно так же, как и упомянутый выше экземпляр RunnerRegistry - в свойстве Properties, но под другим ключом) экземпляр класса RunnerRegistryObserver. Этот экземпляр, во взаимодействии с экземпляром класса RunnerRegistry в той же активной сессии, производит оповещение всех заинтересованных компонентов кода о том, что произошло изменение числа активных исполнителей-адаптеров. Оповещение производится через стандартный для .NET механизм с использованием интерфейса IChangeToken (в самой библиотеке времени выполнения .NET этот механизм используется, например, для отслеживания изменений в источниках конфигурации). 

Обработчик метода GET страницы Razor примера создает наблюдающий исполнитель. Задача фонового процесса в этом наблюдающем исполнителе подписывается на эти оповещения и вызывает при получении каждого оповещения функцию обратного вызова исполнителя. В функцию обратного вызова в качестве результата передается число исполнителей в активной сессии. При каждом вызове функции обратного вызова исполнитель делает это число своим текущим результатом и увеличивает номер достигнутой точки выполнения (значение свойства Position). Таким образом, свойство Position - номер достигнутой точки выполнения - наблюдающего исполнителя - указывает число произошедших изменений его результата (с той поправкой, что начальное значение этого свойства равно 1). Увеличение свойства Position может привести к завершению задачи, возвращаемой вызовом метода GetRequiredAsync исполнителя - в том случае, если при вызове этого метода через комбинацию его параметров StartPosition и Advance было запрошено достижение указанного значения Position. И таких задач в исполнителе этого типа может находиться в состоянии ожидания несколько.

Сценарии на странице примера могут наблюдать за числом активных исполнителей-адаптеров и изменением этого числа двумя способами. Во-первых, один из сценарием периодический (раз в секунду) выполняет опрос этих параметров, обращаясь к точке вызова API /api/GetAvailableObserve (метод действия GetAvailableObserve контроллера API). Этот метод возвращает текущее состояние и текущий результат наблюдающего исполнителя, получаемый вызовом его метода GetAvailable. Результат опроса отображается на странице примера слева.

Второй способ наблюдения - получение оповещения об изменении числа активных исполнителей адаптеров. Группа элементов управления в строках таблицы в правой части страницы позволяет подписаться на такие оповещения. Для подписки на оповещение нужно выбрать готовую (содержащую Ready в колонке State) строку подписки управления. В элементах управления выбранной строки надо указать пороговое значение, при достижении которого срабатывает триггер оповещения (в колонке Fires at), максимальное время ожидания срабатывания в секундах(в колонке Timeout) и нажать кнопку Start (в колонке Action). При успешном создании подписки надпись на кнопке в колонке Action в выбранной строке заменяется на Cancel. Нажатие на кнопку Cancel отменяет (завершает) подписку. Подписка также завершается по истечении времени ожидания и при возникновении ошибки. При завершении подписки надпись на кнопке в колонке Action заменяется на Reset, а в ячейке в колонке State указывается причина завершения. При успешном завершении (Fired) там же указывается количество активных исполнителей-адаптеров непосредственно в момент завершения. Нажатие на кнопку Reset переводит строку подписки опять в состояние готовности (Ready). Если процесс опроса либо срабатывание триггера оповещения обнаруживает, что наблюдающий исполнитель более недоступен, то все готовые строки переводятся в недоступное состояние (Unavailable в колонке State).

Создание подписки на оповещение производится путем обращения из сценария JavaScript в браузере к точке вызова /api/GetRequiredObserve (метод действия GetRequiredObserveAsync контроллера API) в режиме длительного опроса (long poll). Метод обработчика точки вызова вызывает метод GetRequiredAsync наблюдающего исполнителя, с завершением в точке выполнения, соответствующей переданному в параметрах обработчика пороговому значению. Чтобы процесс ожидания был ограничен указанным в параметрах промежутком времени, в метод GetRequiredAsync передается маркер отмены, автоматически отменяемый через этот промежуток. Результат вызова GetRequiredAsync возвращается сценарию в браузере, который нужным образом меняет содержимое строки, в которой была выполнена подписка.

Для простоты подписка для каждой из строк таблицы выполняется отдельным запросом к API. Поэтому, чтобы не нарваться на лимит количества соединений с веб-сайтом, количество подписок ограничено тремя. В реальном рабочем приложении так делать не надо: в нем, как минимум, нужно мультиплексировать все подписки в одном соединении длительного опроса. Или - вообще использовать другой механизм взаимодействия с сервером (WebSocket и пр.). Но в примере подписка сделана максимально просто.

Так же, как и в предыдущем примере, для прекращения работы этого примера необходимо закрыть страницу отображения результата - в этом случае обработчик события закрытия страницы пошлет запрос на прекращение выполнения наблюдающего исполнителя через уже упомянутую точку вызова /api/Abort.

### О клиентской части.
Так как основное предназначение проекта - демонстрация использования библиотеки ActiveSession, предназначенной для реализации серверной части, то клиентская часть проекта - на HTML/CSS/JavaScript, выполняющаяся в браузере - сделана по остаточному принципу. Дизайн - минималистский, сделан только для того, чтобы внешний вид не сильно резал глаза (*мне* не резал глаза - а я в этом плане человек неприхотливый), а управление - не сильно мучило (опять же: *меня* мучило - а я много к чему привычный). Внимание было обращено, в основном, на то, чтобы все работало: управление - управляло, API - вызывались, результаты - отображались. Обработка ошибок, опять же, сделана по минимуму: минимум - есть, но поиском краевых случаев и тщательным тестированием я не заморачивался.

Более того, при создании клиентской части я максимально стремился изолировать друг от друга страницы для разных примеров и сделать их самодостаточными. В результате, страницы оказались противоречащими многим так любимыми теоретиками "наилучшим практикам": код сценариев - свой на каждой странице и на ней же размещен, стили элементов прописаны прямо в их атрибутах, в крайнем случае (для динамически создаваемых элементов, например) - в таблицах стилей, расположенных тоже прямо на той же странице. Были намеренно отвергнуты даже напрашивающиеся оптимизации с выносом повторяющегося на разных страницах кода JavaScript и стилей CSS в общие загружаемые из страницы файлы, и так было сделано специально. А про использование каких либо фреймворков - тут даже речи нет: только голый CSS и JS, только хардкор. Короче, эти страницы не могут быть примером "чистого" дизайна и совсем не предназначены (в отличие от кода серверной части) для копирования их в реальные приложения.  Коли хотите, используйте их на свой страх и риск (лицензия позволяет), но я вас предупредил.

## Проект ProbeApp
Второй проект, ProbeApp, добавлен сюда, скорее, в качестве дополнительной информации, по принципу "шоб було". Рассказать о нем особо нечего. Этот проект использовался на первоначальном этапе разработки библиотеки ActiveSessions, пока ее концепция еще не устоялась, чтобы попробовать разные варианты ее архитектуры. Ну - и чтобы отлаживать первоначальные реализации модулей инфраструктуры: к идее использовать для отладки средство запуска модульных тестов в Visual Studio я пришел не сразу. В частности, данный проект активно использовался для отладки на этапе, когда концепция стандартных исполнителей ещё не сформировалась, а основным способом применения библиотеки предполагалось написание собственных исполнителей, реализующих интерфейс исполнителя. Собственно, именно как пример написания собственного исполнителя этот проект и имеет смысл использовать. С некоторых пор я перестал активно развивать этот проект - только поддерживал его совместимость с изменяемым интерфейсом библиотеки. А в качестве примера  использования библиотеки я написал предыдущий проект. Так что, иллюстрацией создания собственного исполнителя этот проект сейчас, главным образом, и ценен. А примеров основного способа использования библиотеки - применения стандартных исполнителей - в нем нет.

С наилучшими пожеланиями, MVVrus.
