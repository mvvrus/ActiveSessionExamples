# ActiveSessions library usage examples. 
This repository contains usage examples for [ActiveSessions library](https://github.com/mvvrus/ActiveSession).

## SampleApplication project
The first project, SampleApplication, contains an example of configuring an application to use the ActiveSession library and examples of using standard runners. This project consists of four main examples examples, each demonstrating the use of the corresponding runner, and an additional example demonstrating mutually exclusive access to a service from the active session service container. These examples are loosely logically related. Links to each of the examples are on the application entry page.

### Startup code and entry page
The application configuration and startup code in the Program.cs file provides an example of configuring an application to use the ActiveSession library and all its standard runners.

The entry page (the root page of the application - Index.cshtml) contains the identifier of the current active session and a set of links to examples of using the standard runners of the ActiveSession library. Next to the active session identifier is the New button. Clicking this button terminates the current active session and creates a new one - this is done by calling the /api/terminate endpoint (the handler of this endpoint calls the IActiveSession.Terminate method) and reloads the entry page so that a new active session is created for it. Terminatoin of an active session stops all runners running in it.

### General information about examples of using standard runners
Each example contains one or two Razor pages and a set of API endpoints. Endpoints are implemented as MVC API controller actions. If an example includes two Razor pages, the first one, a parameters page, contains a form that collects parameters for the example. The link from the entry page for such an example leads to this page with the form. The form handler checks the entered data and calls (via HTTP Redirect) the second page - the result page, which contains the actual example of using the runner. If there is no need to collect parameters for the example, then such an example contains only the result page, and the link on the entry page leads directly to this result page.

A result page is a Razor page that is used to display the example parameters and results. Each result page has an associated runner that the page demonstrates. A Razor page creates an HTML page that is returned to the browser on the client. Its content is created when the page is rendered by the HTTP GET handler (OnGet or OnGetAsync) according to the example parameters. The initial content displays the example parameters and the initial result received from the runner.

The HTML page sent to the browser contains a set of JavaScript scripts that receive additional results from the runner, display them, and control the runner. The data is received and the runner is controlled through API endpoints of the web application in which the runner is running on the server in the background. These API endpoints are implemented by action methods of the SampleController class. All of them will be listed below, in the description of specific examples. API endpoints receive the external identifier of the runner as part of the parameters passed to them. Then the handlers of these endpoints, using the external identifier of the runner, check that the current active session has not changed, find the requested runner by its number and perform the actions requested through them on this runner.

For each the result page its onclose handler sends a request to terminate the execution of the runner associated with it to the endpoint /api/Abort (the SampleController.Abort method). The implementation of this endpoint handler has a special feature. Since the handler of this endpoint can be called from different sample pages, which are associated with runners with different result types, this handler, unlike other endpoint handlers, cannot use the generic, result type-specified IActiveSession.GetRunner&lt;TResult&gt; method to obtain the runner interface (IRunner&lt;TResult&gt;) or extension methods based on it: if an invalid result type is specified, this method will return null instead of a reference to the runner. Instead, the Abort handler gets a result-type-independent runner interface (the non-generic IRunner interface) via the IActiveSession.GetNonTypedRunner method and calls the runner's Abort method through it.

### Example of using enumeration adapters (EnumAdapterRunner and AsyncEnumAdapterRunner)
This example demonstrates the use of runners - enumeration adapters. The ActiveSession library has two types of such adapters - an adapter for a synchronous (IEnumerable&lt;TItem&gt;) enumeration EnumAdapterRunner and an adapter for an asynchronous (IAsyncEnumerable&lt;TItem&gt;) enumeration AsyncEnumAdapterRunner. Both adapters function in a similar way, so the examples of their usage contain the same pages  and can be considered as one example.

The enumerations for that the runners demonstrated in this example are adapters return a sequence of results that are obtained by calling a function that generates dummy data. This dummy data consists of a call sequence number, a random string, and a random number. An enumeration can contain several stages (at least one). At each stage, the function for getting the data is called the specified number of times with the specified delay between calls, which can be zero.

On the parameters page with the form for collecting the parameters for this example, SequenceAdapterParams.cshtml, you can specify the number of records to display initially, the interval between requests for additional records via the API, and the maximum number of records returned per request. In the table below, you can configure the enumeration stages: add/remove stages and specify the number of calls to be performed at each stage along with the interval between them.

The runner with which the results page works is created by the form handler, and the external identifier of this runner (of the ExtRunnerKey type) is passed to the results page via the ASP.NET Core routing parameter - that is, via the path segment in the URL. Namely, after successfully validating the form data, the form handler creates a runner of the required type and requests redirection to the results page via the returned result. A reference to the class containing the example parameters obtained from the form is written to the ExtraData property of the interface of the created runner. The external identifier of the runner, converted to a string by the ExtRunnerKey.ToString() method, is substituted into the URL path for the results page by the link generation tools of the routing component. This is safe to do, because this string is guaranteed to contain only characters allowed in an URL.

When calling the GET method handler of the results Razor page - SequenceShowResults.cshtml (this handler is asynchronous, it has the name OnGetAsync), the string representing the external key of the runner becomes, in accordance with the address template, the value of the "key"" routing parameter. This parameter is bound to the handler input parameter of the same name, which has the ExtRunnerKey type. The binding is performed by the ExtRunnerKeyMvcModelBinder auxiliary class via the ExtRunnerKey.TryParse method. Based on the information from the parameter, the GET handler checks that the current active session has not changed and finds the runner. The handler then retrieves the example parameters passed to it via reference in the ExtraData property of the runner interface and makes those parameters and the runner's external key available for rendering in the Razor page. Then the handler retrieves (via the runner's GetRequiredAsync method, which may be executed asynchronously) the number of records specified in the example parameters, makes them available to the Razor page for rendering, and returns a result to the framework instructing it to render the page. The Razor code called by the framework that renders the page also saves the runner's foreign key it retrieved into a page-level JavaScript variable. The value of this variable is then used by JavaScript scripts running in the browser to make requests to the application's API.

The HTML results page for this example displays the parameters used in the example on the left. On the right are the current state of the runner and a table with the data received from the runner. Initially, this table contains no more than the number of records specified in the parameters. Subsequently, additional data obtained by requests to the API (endpoint /api/GetAvailable, action method SampleController.GetAvailable) is added to it. The method requests from the runner (via its GetAvailable method) the records already received in the background from the enumerator, but not yet returned to a consumer - either all of them, or only the number specified in the parameters of the example. These records, together with the current state of the runner, also returned by the GetAvailable method, are returned as a result of calling this endpoint and are displayed by the script on the page in the browser.

The execution of the runner can be stopped by clicking the Abort button located under the table. This will send a request to the API endpoint /api/Abort (method SampleController.Abort) which was discussed earlier.

### TimeSeriesRunner Usage Example
This example displays a sequence of records, each of which contains the time and the number of runners - enumeration adapters active at the specified moment. The runners, the number of which is displayed, are those enumeration adapters that are created for the first example (several instances of the example can be launched simultaneously). The first moment for which the number of runners is displayed is the moment of the example launch, then these moments follow through the interval specified on the example parameters page.

To track this data, a reference to an instance of the RunnerRegistry class, tracking the creation and deletion of runners, is saved in the properties of the active session (IActiveSession.Properties) under a predefined key. This instance is created in deferred mode the first time it is accessed. The form data handler from the previous example calls the registration method of this instance for each runner it creates. The registration method adds a reference to the created runner to its internal list. To cancel the registration of a runner upon its completion, this method adds a callback handler to the cancellation token that is accessible through the runner's IRunner.CompletionToken interface property, which is canceled upon runner completion. The callback handler removes the completed runner from the internal list of the RunnerRegistry instance. The counter of the adapter runners registered in this way is displayed at the specified times in the example under consideration.

The parameters page of this example (TimeSeriesParams.cshtml) contains only one field in its form - the time interval in seconds between records created by observing time series runner in the example. The creation of the observing runner for the example, the transfer of its (external) identifier to the result page (TimeSeriesResults.cshtml) and saving this identifier for use in API calls in this example are organized the same way as in the previous example.

The handler of the GET method of the result page of the example searches for the previously created observing runner. Then it requests (by the GetRequiredAsync method) the first record containing the time and number of active adapter runners from the observing runner at the time of its start and renders the page. Subsequent records are retrieved and displayed by a script running on the page in a browser. The script calls the API endpoints /api/GetTimeSeriesAvailRecords (implemented by the GetTimeSeriesAvailRecords action method of the API controller) and /api/GetTimeSeriesRecordAsync (implemented by the GetTimeSeriesRecordAsync action method of the API controller) for new records. The following logic is used to call the API. First, the script calls the first of the specified endpoints from a browser after a delay slightly shorter than the interval between counts set for the runner, asking to return all records received in the background but not yet returned. This is done by calling the GetAvailable method of the runner by the endpoint handler. If there are no such records, then the script calls the second endpoint, which asks the runner to get the next record awaiting for it to appear. This is done by calling the GetRequiredAsync method.

To stop this example, you need to close the result page - in this case, the page close event handler will send a request to terminate the runner via the already mentioned /api/Abort endpoint.

### Example of using the active session process runner (SessionProcessRunner)
This example demonstrates the use of the background session process runner. This example has no additional parameters, and therefore the page with the parameter collection form is missing in it, and the link from the input page leads directly to the Razor page of the result (ObservationResults.cshtml). The background process runner (hereinafter - the observing runner) is created directly in the GET method handler of this page.

The result that the observing runner returns - and this type of runner returns not a set of records, but a single result that can change over time - is the same number of active adapter runners that is tracked in the previous example. But tracking this number is organized differently.

In the active session for this example, an instance of the RunnerRegistryObserver class is created and saved (just like the above-mentioned RunnerRegistry instance - in the Properties property, but under a different key). This instance, in interaction with the RunnerRegistry class instance in the same active session, notifies all interested components of the code that the number of active runner adapters has changed. Notification is performed via the standard .NET mechanism using the IChangeToken interface (in the .NET runtime library itself, this mechanism is used, for example, to track changes in configuration sources).

In the active session for this example, an instance of the RunnerRegistryObserver class is created and saved (just like the above-mentioned RunnerRegistry instance - in the Properties property, but under a different key). This instance, in interaction with the RunnerRegistry class instance in the same active session, notifies all interested components of the code that the number of active runners-adapters has changed. Notification is performed via the standard .NET mechanism using the IChangeToken interface (in the .NET runtime library itself, this mechanism is used, for example, to track changes in configuration sources).

The handler of the GET method of the Razor page of the example creates an observing (or tracking) runner. A background process task in this observing runner subscribes to these notifications and calls the runner's callback function upon receipt of each notification. The number of runners in the active session is passed to the callback function as a result. Each time the callback function is called, the runner makes this number its current result and increases the number of the reached execution point (the value of the Position property). Thus, the Position property - the number of the reached execution point - of the observing runner - indicates the number of changes to its result that have occurred (with the correction that the initial value of this property is 1). Increasing the Position property can lead to the completion of the task returned by calling the GetRequiredAsync method of the runner - in the case when the new Position value reaches the one specified while calling this method that is a sum of StartPosition and Advance method parameters.  And for this type of runner a number of such calls of GetRequiredAsync awaiting the runner's Position to reach their appropriate values can exist simultaneously - that is not the case for other standard (sequence-oriented) runners. So a number of outstanding GetRequiredAsync calls can be used to monitor changes in a number of active adapter runners, and this is used in this example (see below).

The scripts on the example page can monitor the number of active adapter runners and the change in this number in two ways. First, one of the scripts periodically (once per second) polls these parameters by accessing the API endpoint /api/GetAvailableObserve (serving by the GetAvailableObserve action method of the API controller). This method returns the current state and current result of the observing runner, obtained by call of the runner's GetAvailable method. The last poll result is displayed on the example page on its left side.

The second way of monitoring used is to receive a notification about a change in the number of active adapter runners. The group of controls in the table rows on the right side of the page allows you to subscribe to such notifications. To subscribe to a notification, you need to select a ready (containing Ready in the State column) control subscription row. To start running a subcrition one need to specify, using controls of the selected row, the threshold value (in the "Fires at" column), upon reaching which the notification trigger is fired, the maximum wait time for firing (in seconds in the "Timeout(s)" column) and click the Start button (in the Action column). If the subscription is successfully created, the text on the button in the Action column in the selected row is replaced with "Cancel". Clicking the Cancel button cancels (completes) the subscription. The subscription is also completed after the wait time has elapsed and in a case an error occurs. When a subscription is completed, the button text in the Action column is replaced with "Reset", and the cell in the State column indicates the reason for completion. If the subscription is completed successfully (Fired), the number of active adapter runners at the time of completion will also be shown there. Clicking the Reset button switches the subscription row back to the Ready state. If the polling process or a triggering of a notification detects that the observing runner is no longer available, then all ready rows are switched to the unavailable state (with a word Unavailable in the State column).

A notification subscription is created by calling the /api/GetRequiredObserve endpoint (the GetRequiredObserveAsync action method of the API controller) in long poll mode from a JavaScript script in the browser. The endpoint handler method calls the GetRequiredAsync method of the observing runner, with the requested number execution point corresponding to the threshold value passed in the handler parameters. To limit the wait process to the time period specified in the parameters, a cancellation token is passed to the GetRequiredAsync method, which is automatically canceled after this period. The result of the GetRequiredAsync call is returned to the script in a browser, which changes the contents of the row in which the subscription was made apropriately.

For simplicity, the subscription for each table row is made by a separate request to the API. Therefore, in order not to run into the limit of the number of simultaneous connections to the website, the number of subscriptions is limited to three. In a production application this approach shoul be avoided: at least, all subscriptions should be multiplexed in one long polling connection. Or one should use a completely different mechanism for interacting with the server (WebSocket, etc.). But for this example limited in its nature this simple approach is good enough.

Just like the previous example, to stop this example one need to close the result display page - in this case, the page close event handler will send a request to stop the execution of the observing runner via the already mentioned /api/Abort endpoint.

### Example of getting mutually exclusive access to a service from the active session service container (ExclusiveParams)
This example is based on the example of using the asynchronous enumeration adapter. It uses the result page of the enumeration adapter example, but has its own options page. This options page visually resembles the parameters page of the enumeration adapter example, but it is greatly simplified and allows you to enter only the number of calls for the second stage of the enumeration. The remaining parameters - the number of records to initially display, the interval between requests for additional records, the maximum number of records to return per request, the number of stages (two), and the rest of the stage parameters - have fixed values ​​​​that are displayed in the form, but cannot be changed.

The form handler for the result page is asynchronous. First, it checks the received number of second stage calls and forms a parameter structure to pass it to the results display page. Then it asynchronously requests the exclusive accessor to the service and waits for it to be received. If the active session is terminated while waiting for the accessor to be received (all session-related objects are cleared, which causes an ObjectDisposedException during the wait), the handler redirects a browser to a page that reports this fact.

After receiving the exclusive accessor, the form handler performs the same operations as the form handler from the base example, with one exception: an extension method, which takes the accessor to the service as an additional argument, is used to create a runner. Due to this, after the created runner is completed, the accessor will be cleared. And this will make it possible to receive an accessor to the same service to another, waiting, form handler from another instance of the same example, if one exists.

At the same time, when the Submit button is pressed on the form, a script is launched that performs a simplified animation of the waiting process. After receiving a response from the server and displaying a new page, this animation will be stopped.

### About the client part.
Since the main purpose of the project is to demonstrate the use of the ActiveSession library, designed to implement the server part, the client part of the project - consisting of HTML / CSS / JavaScript running in the browser - is made on a residual principle. The design is minimalist, made only so that the appearance is not too annoying (not annoying for *me* - and I am an unpretentious person in this regard), and the control is not too tormenting (again: tormenting to *me* - and I am accustomed to many things). Attention was paid mainly to everything to work: the control - controlled, the API - was called, the results - were displayed. Error handling, again, is done to a minimum: the minimum is there, but I did not bother with searching for corner cases and thorough testing.

Moreover, when creating the client part, I done my best to isolate the pages for different examples from each other and make them self-sufficient. As a result, the pages turned out to be contrary to many of the "best practices" so beloved by theorists: the script code is specific to each page and is located on it, the styles of the elements are written directly in their attributes, in extreme cases (for dynamically created elements, for example) - in style sheets, also located directly on the same page. Even the obvious optimizations like moving JavaScript code and CSS styles repeated on different pages into common files loaded from the pages were deliberately rejected, and this was done on purpose. And there is no talk about using any frameworks here: only bare CSS and JS, only hardcore. In short, these pages cannot be an example of so called "clean code" and are not at all intended (unlike the server part code) to be copied into real applications. If you want, use them at your own risk (the license allows it), but I have warned you.

## ProbeApp Project
The second project, ProbeApp, is added here rather as additional information, on the principle of "just in case". There is not much to say about it. This project was used at the initial stage of development of the ActiveSessions library, while its concept was not yet established, in order to try out different options for its architecture. Well - and to debug the initial implementations of the infrastructure modules: I did not immediately come to the idea of using the Visual Studio IDE unit test infrastructure  for debugging. In particular, this project was actively used for debugging at the stage when the concept of standard runners had not yet formed, and the main way of using the library was to write your own runners implementing the runner interface. Actually, it makes sense to use this project as an example of writing your own runner. For some time now, I have stopped actively developing this project - I only supported its compatibility with the changing interface of the library. And as an example of using the library, I wrote the previous project. So, this project is now mainly valuable as an illustration of creating your own runner. And there are no examples of the main way of using the library - using standard runners.

Best wishes, MVVrus.

